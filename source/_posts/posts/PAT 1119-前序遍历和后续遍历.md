---
title: PAT 1119-前序遍历和后续遍历
url: PAT 1119-前序遍历和_url
tags:
  - 二叉树
categories:
  - PAT
date: 2020-05-08 20:03:00
---
**题目要求：给出二叉树的前序遍历和后序遍历，输出其中序遍历。如果该二叉树不唯一，输出其中任意一个二叉树的中序遍历即可**
# 二叉树的前序和后序遍历
二叉树的前序遍历可概述成：根左右
二叉树的后序遍历可概述成：左右根
我们另pre数组为二叉树前序遍历，post数组为二叉树的后序遍历。易知pre的第一个节点和post的最后一个节点一定为根节点。pre的第二个节点pre[2]要么是左子树根节点，要么是右子树根节点（左子树不存在）。
post的倒数第二个节点post[-2]要么是右子树的根节点，要么是左子树的根节点（当右子树不存在时）
>1. 如果preorder[2]!=postorder[-2]，那就说明preorder[2]和postorder[-2]所代表地根节点不是同一棵树，因此存在左子树和右子树，从而preorder[2]是左子树根节点，postorder[-2]是右子树根节点。
>2. 如果preorder[2]==postorder[-2]，那么就说明只存在一边的子树，其实是只有左子树也可以，只有右子树也可以。所以，存在不同的树的根源就在于这里。
>   这种情况下，我们就可以递归地去判断，只要有一次preorder[2]==postorder[-2]，就说明有多个解，这个时候我们只需要构造左子树（右子树）就可以了。

规律：**所以其实我们可以看出一个规律：只有满二叉树才能通过前序遍历和后序遍历唯一确定**
     **对于非满二叉树来说，前序和后序在本质上都是将父节点与子结点进行分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树。**
```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N	= 40;
int l[N],r[N]; //l[i],r[i]代表i号节点的左右儿子
int pre[N],post[N];
bool is_only=true;
int in[N],cnt=0;
int build(int l1,int r1,int l2,int r2)
{
	int root=pre[l1];
	
	if(l1==r1) return root;
	//根据pre[l1+1]和pre[r2-1]来判断答案是否唯一
	if(pre[l1+1]==post[r2-1])//说明答案不唯一，我们直接认为右儿子不存在即可 
	l[root] = build(l1+1,r1,l2,r2-1), is_only=false;
	else//不相同，那么说明 pre[l1+1]为左儿子的根节点，post[r2-1]为右儿子根节点 
	{
		int lpre,rpost;//lpre代表前序序列中左子树的右边界，rpost代表后序序列中右子树的 左边界 
		for(lpre=l1+1;lpre<=r1;lpre++)  if(pre[lpre]==post[r2-1]) break;
		for(rpost=r2-1;rpost>=l2;rpost--) if(post[rpost]==pre[l1+1]) break;
		lpre--,rpost++;
		l[root] = build(l1+1,lpre,l2,rpost-1);
		r[root] = build(lpre+1,r1,rpost,r2-1); 
	} 
	return root;
}
void inorder(int root)
{
	if(l[root]!=-1) inorder(l[root]);
	in[cnt++] =root;
	if(r[root]!=-1) inorder(r[root]);
}

int main()
{
	memset(l,-1,sizeof(l));
	memset(r,-1,sizeof(r));
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		cin>>pre[i];
	for(int i=0;i<n;i++)
		cin>>post[i];
		
	//根据前序遍历和后续遍历创建二叉树
	int root=build(0,n-1,0,n-1); 
	
	if(is_only) puts("Yes");
	else puts("No");
	inorder(root);
	cout<<in[0];
	for(int i=1;i<n;i++)
		cout<<" "<<in[i];
} 
```

<!-- more -->


